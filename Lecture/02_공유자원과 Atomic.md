## Atomic

* std::atomic : 다중 스레드 환경에서 안전하게 공유 자원을 수정
* 여러 스레드가 동시에 공유 자원에 접근해도 데이터 무결성과 일관성을 보장할 수 있음  

  
* 특징
  * __원자적 연산__ : 연산이 원자적으로 실행된다, 해당 연산이 다른 스레드에 의해 중단되거나 간섭되지 않음
  * __메모리 가시성__ : 공유 변수의 값을 읽거나 쓸 때 가시성 보장, 스레드가 변수의 변경 사항을 다른 스레드에게 정확히 알림
  * __변수 형식 지정__ : 여러가지 데이터 타입에 대해 사용 가능
  * __원자적 연산 함수__ : fetch_add, store, load 등의 함수를 사용해 증가, 할당, 읽기 작업 수행 가능  
  
  
* 그러면 멀티스레드에서 공유 자원을 변경하지 않으면 굳이 atomic을 사용하지 않아도 되는가?
  * Yes, 다만 "읽기-쓰기 경합 조건(Race Condition)"이 발생하지 않도록 공유 자원에 접근하는 것이 중요   

  
* __Race Condition__ : 경합조건, 멀티스레드나 멀티 프로세스 환경에서 공유 자원에 대한 접근이 동기화 되지 않아 발생
  * 데이터 무결성 손실 : 데이터의 일관성이 손상되어 공유 자원 상태가 예측 불가능해질 수도 있다.
  * 정확성 문제 : 경합조건으로 인해 계산 또는 연산이 예상치 못한 결과 초래할 수도 있음
  * 데드락(Deadlock) : 동기화를 위해 스레드 혹은 프로세스가 무한히 대기하는 상태로 빠질 수 있음  
 
* 일반적인 동기화 메커니즘 : 뮤텍스(Mutex), 세마포어(Semaphore), 크리티컬 섹션(Critical Section) 등 존재  
